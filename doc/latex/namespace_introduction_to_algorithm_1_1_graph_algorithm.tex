\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm}{}\section{Introduction\+To\+Algorithm\+:\+:Graph\+Algorithm Namespace Reference}
\label{namespace_introduction_to_algorithm_1_1_graph_algorithm}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}


Namespace of \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm}{Graph\+Algorithm}.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_a_d_j_list_graph}{A\+D\+J\+List\+Graph}
\begin{DoxyCompactList}\small\item\em A\+D\+J\+List\+Graph：图的邻接表表示，算法导论22章22.1节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_b_f_s___vertex}{B\+F\+S\+\_\+\+Vertex}
\begin{DoxyCompactList}\small\item\em B\+F\+S\+\_\+\+Vertex：用于广度优先搜索的顶点类型，算法导论22章22.2节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_d_f_s___vertex}{D\+F\+S\+\_\+\+Vertex}
\begin{DoxyCompactList}\small\item\em D\+F\+S\+\_\+\+Vertex：用于深度优先搜索的顶点类型，算法导论22章22.3节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_edge}{Edge}
\begin{DoxyCompactList}\small\item\em Edge：图的边，算法导论22章22.1节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_graph}{Graph}
\begin{DoxyCompactList}\small\item\em Graph：图，算法导论22章22.1节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_matrix_graph}{Matrix\+Graph}
\begin{DoxyCompactList}\small\item\em Matrix\+Graph：图的矩阵表示，算法导论22章22.1节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_set_vertex}{Set\+Vertex}
\begin{DoxyCompactList}\small\item\em Set\+Vertex：图的顶点，它带一个node属性，算法导论22章22.1节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_vertex}{Vertex}
\begin{DoxyCompactList}\small\item\em Vertex：图的顶点，算法导论22章22.1节 \end{DoxyCompactList}\item 
struct \hyperlink{struct_introduction_to_algorithm_1_1_graph_algorithm_1_1_vertex_p}{Vertex\+P}
\begin{DoxyCompactList}\small\item\em Vertex\+P：图的顶点，它带一个parent属性，算法导论22章22.1节 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Graph\+Type $>$ }\\void \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a31fe8fc6f732112632c51221e739a7d4}{connected\+\_\+component} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph)
\begin{DoxyCompactList}\small\item\em connected\+\_\+component：无向图的连通分量，算法导论21章21.1节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type $>$ }\\bool \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_ac368f242de9f06c7d936cba4aa0ab40b}{same\+\_\+component} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type id1, typename Graph\+Type\+::\+V\+I\+D\+Type id2)
\begin{DoxyCompactList}\small\item\em same\+\_\+component：返回无向图的两个顶点是否位于同一个连通分量中。算法导论21章21.1节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$ void(typename Graph\+Type\+::\+V\+I\+D\+Type)$>$$>$ }\\void \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a9c57b397479972f84b4b10bc19968297}{breadth\+\_\+first\+\_\+search} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id, Action\+Type pre\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type)\{\}, Action\+Type post\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type)\{\})
\begin{DoxyCompactList}\small\item\em breadth\+\_\+first\+\_\+search：广度优先搜索，算法导论22章22.2节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$void(typename Graph\+Type\+::\+V\+I\+D\+Type,int)$>$$>$ }\\void \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_af651a2b435fc270ab711e573d83a385d}{visit} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type v\+\_\+id, int \&time, Action\+Type pre\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, int)\{\}, Action\+Type post\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, int)\{\})
\begin{DoxyCompactList}\small\item\em visit：深度优先搜索的辅助函数，用于访问顶点，算法导论22章22.3节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$void(typename Graph\+Type\+::\+V\+I\+D\+Type,int)$>$$>$ }\\void \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a3bb9faf89f84f73b716c25966786e078}{depth\+\_\+first\+\_\+search} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, Action\+Type pre\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, int)\{\}, Action\+Type post\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, int)\{\}, Action\+Type pre\+\_\+root\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, int)\{\}, Action\+Type post\+\_\+root\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, int)\{\}, const std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$ \&search\+\_\+order=std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$())
\begin{DoxyCompactList}\small\item\em depth\+\_\+first\+\_\+search：深度优先搜索，算法导论22章22.3节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type $>$ }\\const std\+::vector$<$ std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$ $>$ \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a6d058c2aaa8714778b3f2ab8a24ff232}{scc} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph)
\begin{DoxyCompactList}\small\item\em scc：强连通分量，算法导论22章22.5节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type $>$ }\\std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$ \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a804241e72be5f4c031190bc12a6b73a2}{topology\+\_\+sort} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph)
\begin{DoxyCompactList}\small\item\em topology\+\_\+sort：拓扑排序，算法导论22章22.4节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$ void(typename Graph\+Type\+::\+V\+I\+D\+Type,typename Graph\+Type\+::\+V\+I\+D\+Type)$>$$>$ }\\Graph\+Type\+::\+E\+Weight\+Type \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a2575c09c42d0b30b57702c9379d2fbfb}{kruskal} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, Action\+Type pre\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, typename Graph\+Type\+::\+V\+I\+D\+Type)\{\}, Action\+Type post\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type, typename Graph\+Type\+::\+V\+I\+D\+Type)\{\})
\begin{DoxyCompactList}\small\item\em kruskal：最小生成树的\+Kruskal算法，算法导论22章23.2节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$ void(typename Graph\+Type\+::\+V\+I\+D\+Type)$>$$>$ }\\Graph\+Type\+::\+E\+Weight\+Type \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_aba1581358d79ba82dc4fd0c15bc987e6}{prim} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id, Action\+Type pre\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type)\{\}, Action\+Type post\+\_\+action=\mbox{[}$\,$\mbox{]}(typename Graph\+Type\+::\+V\+I\+D\+Type)\{\})
\begin{DoxyCompactList}\small\item\em prim：最小生成树的\+Prim算法，算法导论22章23.2节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type $>$ }\\void \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a5ed496e8825564d0f9fcfe3b0ac41dec}{initialize\+\_\+single\+\_\+source} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id)
\begin{DoxyCompactList}\small\item\em initialize\+\_\+single\+\_\+source：单源最短路径的初始化操作，算法导论22章xx节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vertex\+Type $>$ }\\void \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_afe2bd83fca7df7e07ece9a59b8e7f5a6}{relax} (std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ from, std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ to, typename Vertex\+Type\+::\+Key\+Type weight)
\begin{DoxyCompactList}\small\item\em relax：单源最短路径的松弛操作，算法导论22章xx节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Graph\+Type $>$ }\\bool \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_ae96d9b844260ee3ce9225055040c631b}{bellman\+\_\+ford} (std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id)
\begin{DoxyCompactList}\small\item\em bellman\+\_\+ford：单源最短路径的bellman\+\_\+ford算法，算法导论22章xx节 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a19237111c3b1ec2717c5e1aefe2f6d9b}{unlimit} ()
\begin{DoxyCompactList}\small\item\em unlimit：返回正无穷的函数 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a4f664c13605fc87ca8d26f4aad5a9fa2}{is\+\_\+unlimit} (T t)
\begin{DoxyCompactList}\small\item\em is\+\_\+unlimit：判断是否正无穷 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vertex\+Type $>$ }\\std\+::vector$<$ typename Vertex\+Type\+::\+V\+I\+D\+Type $>$ \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm_a1581960f77507024b39572aeb6d1fbd6}{get\+\_\+path} (const std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ v\+\_\+from, const std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ v\+\_\+to)
\begin{DoxyCompactList}\small\item\em get\+\_\+path：获取两个顶点之间的路径 \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace of \hyperlink{namespace_introduction_to_algorithm_1_1_graph_algorithm}{Graph\+Algorithm}. 

该命名空间内包含所有图算法 

\subsection{Function Documentation}
\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_ae96d9b844260ee3ce9225055040c631b}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!bellman\+\_\+ford@{bellman\+\_\+ford}}
\index{bellman\+\_\+ford@{bellman\+\_\+ford}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{bellman\+\_\+ford(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type $>$ bool Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::bellman\+\_\+ford (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{source\+\_\+id}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_ae96d9b844260ee3ce9225055040c631b}


bellman\+\_\+ford：单源最短路径的bellman\+\_\+ford算法，算法导论22章xx节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强指针，必须非空。若为空则抛出异常} & \\
\hline
{\em source\+\_\+id：最小生成树的根结点$<$tt$>$id$<$/tt$>$，必须有效。若无效则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 是否不包含可以从源结点可达的权重为负值的环路。若返回值为true，则说明不包含可以从源结点可达的权重为负值的环路
\end{DoxyReturn}
单源最短路径问题：给定一个带权重的有向图\+G=(V,E)和权重函数w\+:E-\/$>$R，该权重函数将每条边映射到实数值的权重上。图中一条路径p=$<$v0,v1,...vk$>$的权重 w(p)=w(v0,v1)+w(v1,v2)+...+w(v(k-\/1),vk)。定义结点u到结点v的最短路径权重 delt(u,v)为：


\begin{DoxyItemize}
\item min\{w(p)\+:u--$>$v(通过路径p)\}，如果存在一条从结点u到结点v的路径
\item 正无穷 ，如果不存在一条从结点u到结点v的路径
\end{DoxyItemize}

从结点u到结点v的最短路径定义为任何一条权重w(p)=delt(u,v)的从u到v的路径p。

给定图\+G=(V,E)，对每个结点v我们维持一个前驱结点v.\+pai。在最短路径算法中，由pai值诱导的前驱子图\+G\+\_\+pai=(V\+\_\+pai,E\+\_\+pai)，其中 V\+\_\+pai=\{v属于\+V\+:v.\+pai!=nil\}并上源点s， E\+\_\+pai是\+V\+\_\+pai中所有结点的pai值诱导的边的集合：\+E\+\_\+pai=\{(v.\+pai,v)属于\+E\+:v属于\+V\+\_\+pai-\/\{s\} \}。算法终止时，\+G\+\_\+pai是一棵最短路径树：该树包含了从源结点s 到每个可以从s到达的结点的一条最短路径。

需要指出的是：最短路径不一定是唯一的，最短路径树叶不一定是唯一的。

Bellman-\/\+Ford算法解决的是一般情况下的单源最短路径问题。在这里边的权重可以为负值。给定带权的有向图\+G=(V,E)和权重函数w\+:E-\/$>$R，\+Bellman-\/\+Ford 算法返回一个bool值，表明是否存在一个从源结点可达的权重为负值的环路。若存在这样的一个环路，算法告诉我们不存在解决方案；若不存在这样的环路， 算法将给出最短路径和它们的权重。

Bellman-\/\+Ford算法通过对边的松弛操作来渐近的降低从源s到每个结点v的最短路径估计值v.key，直到该估计值与实际的最短路径权重相同为止。算法步骤：


\begin{DoxyItemize}
\item 执行单源最短路径的初始化过程
\item 进行$\vert$\+V$\vert$-\/1次处理，每次处理过程为：对图的每一条边进行一次松弛操作
\item 检查图中是否存在权重为负的环路并返回与之相适应的布尔值
\end{DoxyItemize}

性能：时间复杂度为\+O(\+V\+E) 

Definition at line 132 of file bellmanford.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a9c57b397479972f84b4b10bc19968297}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!breadth\+\_\+first\+\_\+search@{breadth\+\_\+first\+\_\+search}}
\index{breadth\+\_\+first\+\_\+search@{breadth\+\_\+first\+\_\+search}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{breadth\+\_\+first\+\_\+search(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id, Action\+Type pre\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type)\lcurly{}\rcurly{}, Action\+Type post\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type)\lcurly{}\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$ void(typename Graph\+Type\+::\+V\+I\+D\+Type)$>$$>$ void Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::breadth\+\_\+first\+\_\+search (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{source\+\_\+id, }
\item[{Action\+Type}]{pre\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType)\{\}}, }
\item[{Action\+Type}]{post\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType)\{\}}}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a9c57b397479972f84b4b10bc19968297}


breadth\+\_\+first\+\_\+search：广度优先搜索，算法导论22章22.2节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强引用，必须非空。若为空则抛出异常} & \\
\hline
{\em source\+\_\+id：广度优先搜索的源点$<$tt$>$id$<$/tt$>$，必须有效。若无效则抛出异常} & \\
\hline
{\em pre\+\_\+action\+:一个可调用对象，在每次发现一个顶点时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em post\+\_\+action\+:一个可调用对象，在每次对一个顶点搜索完成时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+:void
\end{DoxyReturn}
{\ttfamily source\+\_\+id}在以下情况下无效：


\begin{DoxyItemize}
\item {\ttfamily source\+\_\+id}不在区间{\ttfamily \mbox{[}0,N)}之间时，{\ttfamily source\+\_\+id}无效
\item {\ttfamily graph}中不存在某个顶点的{\ttfamily id}等于{\ttfamily source\+\_\+id}时，{\ttfamily source\+\_\+id}无效
\end{DoxyItemize}

广度优先搜索：该算法维护已经发现结点和未发现结点的边界，沿着其广度方向向外扩展。每个结点有三种颜色：白色、灰色、黑色。 白色结点表示未发现；灰色结点表示已发现但是未处理完成；黑色结点表示已处理完成。其中灰色结点就是边界。

给定图 G=(V,E)和一个可以识别的源点{\ttfamily s}。。所有的结点在一开始都被涂上白色。每个结点的颜色存放在属性{\ttfamily color}中； 每个结点的前驱结点放在属性{\ttfamily parent}中。每个结点的属性{\ttfamily key}存放的是从源点到本结点的距离。该算法使用一个先进先出的队列\+Q来管理灰色结点集。


\begin{DoxyItemize}
\item 将所有结点涂为白色，{\ttfamily key}属性设置为正无穷，父结点置为空；
\item 将源点涂为灰色，源点前驱设为空，源点的{\ttfamily key}设为0；
\item 将源点加入队列\+Q中；\+Q中存放的都是已发现但是尚未处理完成的结点
\item 循环直到队列\+Q为空，在循环中执行以下操作：
\begin{DoxyItemize}
\item 取出队列\+Q头部的结点{\ttfamily v}
\item 对结点{\ttfamily v}的邻接表中的白色结点进行发现操作，并将这些结点加入队列\+Q中
\item 对结点{\ttfamily v}染成黑色；
\end{DoxyItemize}
\end{DoxyItemize}

算法的时间复杂度为 O(E+\+V)

最短路径：广度优先搜索能找出给定源结点s到所有可以到达的结点之间的距离。定义从源s到结点v之间的最短路径距离 delt(s,v) 为从结点s到v之间的所有路径里面最少的边数。 如果从s到v没有路径，则 delt(s,v)=正无穷大 。我们定义从s到v之间的长度为 delt(s,v) 的路径为 s 到 v 的最短路径。可以证明：广度优先搜索可以正确计算出最短路径距离。

广度优先树：对于\+G=(V,E)和源点s，定义图\+G的前驱子图为 G\+\_\+pai=(V\+\_\+pai,E\+\_\+pai)，其中 V\+\_\+pai=\{ v属于\+V\+: v.\+parent!=N\+I\+L\}并上\{s\}，\+E\+\_\+pai=\{(v.\+parent,v)\+:v属于(V\+\_\+pai-\/\{s\})\}。 即\+V\+\_\+pai由从源s可达的所有结点组成（包括s本身），\+E\+\_\+pai由\+V\+\_\+pai中去掉s之后的结点的入边组成，其中该入边的对端为结点的父结点。 B\+F\+S算法获取的前驱子图\+G\+\_\+pai包含一条从源结点s到结点v的唯一简单路径，而且该路径也是图\+G里面从源s到v之间的一条最短路径，因此前驱子图也称为广度优先树。 

Definition at line 176 of file bfs.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a31fe8fc6f732112632c51221e739a7d4}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!connected\+\_\+component@{connected\+\_\+component}}
\index{connected\+\_\+component@{connected\+\_\+component}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{connected\+\_\+component(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type $>$ void Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::connected\+\_\+component (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a31fe8fc6f732112632c51221e739a7d4}


connected\+\_\+component：无向图的连通分量，算法导论21章21.1节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强指针，必须非空。若为空则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+:void
\end{DoxyReturn}
connected\+\_\+component函数使用不相交集合操作来计算一个无向图的连通分量。一旦connected\+\_\+component函数与处理了该图，same\+\_\+component 函数就会回答两个顶点是否在同一个连通分量。

connected\+\_\+component算法步骤：


\begin{DoxyItemize}
\item 将每个顶点v放入它自己的集合中
\item 对每一条边(u,v)，它将包含u和v的集合进行合并
\end{DoxyItemize}

在处理完搜有边之后，两个顶点在相同的连通分量当且仅当与之对应的对象在相同的集合中 

Definition at line 94 of file connectedcomponent.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a3bb9faf89f84f73b716c25966786e078}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!depth\+\_\+first\+\_\+search@{depth\+\_\+first\+\_\+search}}
\index{depth\+\_\+first\+\_\+search@{depth\+\_\+first\+\_\+search}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{depth\+\_\+first\+\_\+search(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, Action\+Type pre\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, int)\lcurly{}\rcurly{}, Action\+Type post\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, int)\lcurly{}\rcurly{}, Action\+Type pre\+\_\+root\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, int)\lcurly{}\rcurly{}, Action\+Type post\+\_\+root\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, int)\lcurly{}\rcurly{}, const std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$ \&search\+\_\+order=std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$void(typename Graph\+Type\+::\+V\+I\+D\+Type,int)$>$$>$ void Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::depth\+\_\+first\+\_\+search (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{Action\+Type}]{pre\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,int)\{\}}, }
\item[{Action\+Type}]{post\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,int)\{\}}, }
\item[{Action\+Type}]{pre\+\_\+root\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,int)\{\}}, }
\item[{Action\+Type}]{post\+\_\+root\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,int)\{\}}, }
\item[{const std\+::vector$<$ typename Graph\+Type\+::\+V\+I\+D\+Type $>$ \&}]{search\+\_\+order = {\ttfamily std\+:\+:vector$<$typename~GraphType\+:\+:VIDType$>$()}}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a3bb9faf89f84f73b716c25966786e078}


depth\+\_\+first\+\_\+search：深度优先搜索，算法导论22章22.3节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强引用，必须非空。若为空则抛出异常} & \\
\hline
{\em pre\+\_\+root\+\_\+action\+:一个可调用对象，在每次发现一个顶点且该顶点是深度优先森林的根节点时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$以及发现时间$<$tt$>$time$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em post\+\_\+root\+\_\+action\+:一个可调用对象，在每次对一个顶点搜索完成时且该顶点是深度优先森林的根节点时调用调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$以及发现时间$<$tt$>$time$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em pre\+\_\+action\+:一个可调用对象，在每次发现一个顶点时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$以及发现时间$<$tt$>$time$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em post\+\_\+action\+:一个可调用对象，在每次对一个顶点搜索完成时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$以及发现时间$<$tt$>$time$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em search\+\_\+order\+:指定搜索顶点的顺序（不同的搜索顺序可能形成的深度优先森林不同)，如果为空则按照顶点的$<$tt$>$id$<$/tt$>$顺序。默认为空} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+:void
\end{DoxyReturn}
深度优先搜索：深度优先搜索总是对最近才发现的结点v的出发边进行搜索，直到该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，则“回溯”到v的前驱结点（v是经过该结点才被发现的）。 该过程一直持续到源结点可以达到的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程。该算法重复整个过程， 直到图中的所有结点被发现为止。

深度优先搜索维护一个全局的时间。每个结点v有两个时间戳，discover\+\_\+time记录了v第一次被发现的时间（v涂上灰色的时刻）；finish\+\_\+time记录了搜索完成v的相邻结点的时间（v涂上黑色的时刻）。 结点v在v.\+discover\+\_\+time之前为白色，在v.\+discover\+\_\+time之后与v.\+finish\+\_\+time之前为灰色，在v.\+finish\+\_\+time之后为黑色

深度优先搜索步骤：


\begin{DoxyItemize}
\item 初始化：将所有结点染白色，并将它们的父结点置为空(由于\+D\+F\+S\+\_\+\+Vertex构造函数将结点color设为白色，且将父结点置为空，因此在本算法中这个步骤可以省略)
\item 将全局时间 time 置为0
\item 遍历结点集\+V，取出结点v -\/若v是白色的（尚未发现），则调用 visit 操作 \begin{quote}
当这里调用 visit 操作时，结点v会成为一棵树的根

深度优先搜索的结果会依赖于遍历结点集\+V的顺序。不同的遍历顺序得到的结果会不同 \end{quote}

\end{DoxyItemize}

深度优先搜索性能：时间复杂度 O(V+\+E)

深度优先搜索的性质：证明请参考《算法导论》\+:


\begin{DoxyItemize}
\item 深度优先搜索生成的前驱子图\+G\+\_\+pai是一个由多棵树构成的森林
\item 结点 v 是结点 u 在深度优先森林中的后代当且仅当结点v在结点u为灰色的时间段内被发现
\item 结点的发现时间和完成时间具有括号化结构：如果以左括号\char`\"{}(u\char`\"{}来表示结点u被发现，以后括号\char`\"{}u)\char`\"{}表示结点u完成。则发现和完成的历史记载会形成一个规整的表达式。 在深度优先搜索中，对于任意两个结点u和v来说，下面三种情况只有一种成立
\begin{DoxyItemize}
\item 区间\mbox{[}u.\+discover\+\_\+time,u.\+finish\+\_\+time\mbox{]}与区间\mbox{[}v.\+discover\+\_\+time,v.\+finish\+\_\+time\mbox{]}完全分离。 此时在深度优先森林中，结点u不是结点v的后代，结点v也不是结点u的后代
\item 区间\mbox{[}u.\+discover\+\_\+time,u.\+finish\+\_\+time\mbox{]}完全包含在\mbox{[}v.\+discover\+\_\+time,v.\+finish\+\_\+time\mbox{]}，此时在深度优先森林中，结点u是结点v的后代
\item 区间\mbox{[}v.\+discover\+\_\+time,v.\+finish\+\_\+time\mbox{]}完全包含在\mbox{[}u.\+discover\+\_\+time,u.\+finish\+\_\+time\mbox{]}，此时在深度优先森林中，结点v是结点u的后代
\end{DoxyItemize}
\end{DoxyItemize}

深度优先森林的边：对于在图\+G上运行深度优先搜索算法所生成的深度优先森林\+G\+\_\+pai，可以定义四种类型的边：


\begin{DoxyItemize}
\item 树边：它是深度优先森林的边。若结点v是因深度优先算法对边(u,v)的搜索而首先被发现，则(u,v)是一条树边
\item 后向边： 后向边(u,v)将结点u连接到其深度优先树中某个祖先结点v。对于有向图的自循环，自循环被认为是后向边
\item 前向边： 将结点u连接到其在深度优先树中一个后代结点v
\item 横向边： 其他的边。这些边可以连接同一棵深度优先树中的结点（只要其中一个结点不是另外一个结点的祖先），也可以连接不同深度优先树中的两个结点。
\end{DoxyItemize}

在深度优先搜索中，当第一次搜索边(u,v)时：


\begin{DoxyItemize}
\item 若结点v为白色，表明边(u,v)是一条树边
\item 若结点v为灰色，表明边(u,v)是一条后向边
\item 若结点v为黑色，表明边(u,v)是一条前向边或者横向边
\begin{DoxyItemize}
\item 在 u.\+discover\+\_\+time$<$ v.\+discover\+\_\+time 时，为前向边
\item 在 u.\+discover\+\_\+time$<$ v.\+discover\+\_\+time 时，为横向边
\end{DoxyItemize}
\end{DoxyItemize}

在无向图中，每条边要么是树边，要么是后向边。从来不会出现前向边和横向边。 

Definition at line 248 of file dfs.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a1581960f77507024b39572aeb6d1fbd6}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!get\+\_\+path@{get\+\_\+path}}
\index{get\+\_\+path@{get\+\_\+path}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{get\+\_\+path(const std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ v\+\_\+from, const std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ v\+\_\+to)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vertex\+Type $>$ std\+::vector$<$typename Vertex\+Type\+::\+V\+I\+D\+Type$>$ Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::get\+\_\+path (
\begin{DoxyParamCaption}
\item[{const std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$}]{v\+\_\+from, }
\item[{const std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$}]{v\+\_\+to}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a1581960f77507024b39572aeb6d1fbd6}


get\+\_\+path：获取两个顶点之间的路径 


\begin{DoxyParams}{Parameters}
{\em v\+\_\+from} & 起始顶点 \\
\hline
{\em v\+\_\+to} & 终止顶点 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 两个顶点之间的路径包含的顶点的{\ttfamily id}序列
\end{DoxyReturn}
获取从{\ttfamily v\+\_\+from}到{\ttfamily v\+\_\+to}之间的一条路径，该路径用途经的顶点的{\ttfamily id}来表示，是一个{\ttfamily std\+::vector$<$typename Vertex\+Type\+::\+V\+I\+D\+Type$>$}类型。

要求{\ttfamily v\+\_\+from}与{\ttfamily v\+\_\+to}非空，否则抛出异常 

Definition at line 140 of file header.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a5ed496e8825564d0f9fcfe3b0ac41dec}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!initialize\+\_\+single\+\_\+source@{initialize\+\_\+single\+\_\+source}}
\index{initialize\+\_\+single\+\_\+source@{initialize\+\_\+single\+\_\+source}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{initialize\+\_\+single\+\_\+source(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type $>$ void Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::initialize\+\_\+single\+\_\+source (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{source\+\_\+id}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a5ed496e8825564d0f9fcfe3b0ac41dec}


initialize\+\_\+single\+\_\+source：单源最短路径的初始化操作，算法导论22章xx节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强指针，必须非空。若为空则抛出异常} & \\
\hline
{\em source\+\_\+id：最小生成树的根结点$<$tt$>$id$<$/tt$>$，必须有效。若无效则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: void
\end{DoxyReturn}
{\ttfamily source\+\_\+id}在以下情况下无效：


\begin{DoxyItemize}
\item {\ttfamily source\+\_\+id}不在区间{\ttfamily \mbox{[}0,N)}之间时，{\ttfamily source\+\_\+id}无效
\item {\ttfamily graph}中不存在某个顶点的{\ttfamily id}等于{\ttfamily source\+\_\+id}时，{\ttfamily source\+\_\+id}无效
\end{DoxyItemize}

单源最短路径的初始化操作将所有的结点的{\ttfamily key}设置为正无穷，将所有结点的{\ttfamily parent}设为空。然后将源结点的{\ttfamily key}设为0。

性能：时间复杂度\+O(\+V) 

Definition at line 43 of file bellmanford.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a4f664c13605fc87ca8d26f4aad5a9fa2}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!is\+\_\+unlimit@{is\+\_\+unlimit}}
\index{is\+\_\+unlimit@{is\+\_\+unlimit}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{is\+\_\+unlimit(\+T t)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::is\+\_\+unlimit (
\begin{DoxyParamCaption}
\item[{T}]{t}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a4f664c13605fc87ca8d26f4aad5a9fa2}


is\+\_\+unlimit：判断是否正无穷 


\begin{DoxyParams}{Parameters}
{\em t} & 待判断的数 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 如果该数是正无穷大，则返回{\ttfamily true}，否则返回{\ttfamily false}
\end{DoxyReturn}
将本函数判断一个数是否正无穷；若是则返回true;若不是则返回false

这里将大于等于{\ttfamily std\+::numeric\+\_\+limits$<$T$>$\+::max()/3}的数判断结果为正无穷 $>$因为考虑到正无穷减去一个数必须保证结果也是正无穷 

Definition at line 125 of file header.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a2575c09c42d0b30b57702c9379d2fbfb}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!kruskal@{kruskal}}
\index{kruskal@{kruskal}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{kruskal(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, Action\+Type pre\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, typename Graph\+Type\+::\+V\+I\+D\+Type)\lcurly{}\rcurly{}, Action\+Type post\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, typename Graph\+Type\+::\+V\+I\+D\+Type)\lcurly{}\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$ void(typename Graph\+Type\+::\+V\+I\+D\+Type,typename Graph\+Type\+::\+V\+I\+D\+Type)$>$$>$ Graph\+Type\+::\+E\+Weight\+Type Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::kruskal (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{Action\+Type}]{pre\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,typename~GraphType\+:\+:VIDType)\{\}}, }
\item[{Action\+Type}]{post\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,typename~GraphType\+:\+:VIDType)\{\}}}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a2575c09c42d0b30b57702c9379d2fbfb}


kruskal：最小生成树的\+Kruskal算法，算法导论22章23.2节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强指针，必须非空。若为空则抛出异常} & \\
\hline
{\em source\+\_\+id：最小生成树的根结点$<$tt$>$id$<$/tt$>$，必须有效。若无效则抛出异常} & \\
\hline
{\em pre\+\_\+action\+:一个可调用对象，在每次从最小优先级队列中弹出最小顶点时立即调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em post\+\_\+action\+:一个可调用对象，在每次从最小优先级队列中弹出最小顶点并处理完它的边时立即调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 最小生成树的权重
\end{DoxyReturn}
最小生成树：对于一个连通无向图\+G=(V,E)，对于每一条边(u,v)属于\+E都赋予了一个权重w(u,v)。我们希望找出一个无环子集\+T，其中\+T为\+E的子集，使得所有的顶点\+V位于\+T中， 同时\+T具有最小的权重。由于\+T是无环的，且连通所有结点因此\+T必然是一棵树。我们称这样的树为生成树。称从\+G中求取该生成树的问题为最小生成树问题。

通用的最小生成树使用贪心策略。该策略在每个时刻找到最小生成树的一条边，并在整个策略过程中维持循环不变式：边的集合\+A在每次循环之前是某棵最小生成树的一个子集。

在每一步，选择一条边(u,v)，将其加入集合\+A中，使得\+A不违反循环不变式。称这样的边(u,v)为边集合\+A的安全边。

在\+Kruskal算法中集合\+A是一个森林，其结点就是\+G的结点。\+Kruskal算法找到安全边的办法是：在所有连接森林中两棵不同树的边里面，找到权重最小的边(u,v)。

Kruskal算法使用一个不相交集合数据结构来维护几个互不相交的元素集合。每个集合代表当前森林中的一棵树。算法步骤如下：


\begin{DoxyItemize}
\item 初始化：将集合\+A置为空；对\+G中的每一个结点v,以它为根构造一棵单根树
\item 将\+G中的边\+E按照权重单调递增的顺序排序
\item 循环挑选\+E中的(u,v)，按照单调增的顺序。在循环内执行：
\begin{DoxyItemize}
\item 如果u所在的树不等于v所在的树，则将(u,v)加入\+A中，并且合并u所在的树与v所在的树
\end{DoxyItemize}
\end{DoxyItemize}

$>$根据算法的特征，如果图中只有一个顶点，算法得到的集合\+A为空集；但是实际上集合\+A应该包含该顶点。这是算法在极端情况下的\+B\+U\+G。

性能：\+Kruskal算法运行时间依赖于不相交集合数据结构的实现方式。如果采用算法导论21.3节讨论的不相交集合森林实现（也是我在src/set\+\_\+algorithms/disjoint\+\_\+set中实现的）， 则\+Kruskal算法的时间为 O(\+Elg\+V) 

Definition at line 62 of file kruskal.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_aba1581358d79ba82dc4fd0c15bc987e6}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!prim@{prim}}
\index{prim@{prim}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{prim(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type source\+\_\+id, Action\+Type pre\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type)\lcurly{}\rcurly{}, Action\+Type post\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type)\lcurly{}\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$ void(typename Graph\+Type\+::\+V\+I\+D\+Type)$>$$>$ Graph\+Type\+::\+E\+Weight\+Type Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::prim (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{source\+\_\+id, }
\item[{Action\+Type}]{pre\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType)\{\}}, }
\item[{Action\+Type}]{post\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType)\{\}}}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_aba1581358d79ba82dc4fd0c15bc987e6}


prim：最小生成树的\+Prim算法，算法导论22章23.2节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强指针，必须非空。若为空则抛出异常} & \\
\hline
{\em source\+\_\+id：最小生成树的根结点$<$tt$>$id$<$/tt$>$，必须有效。若无效则抛出异常} & \\
\hline
{\em pre\+\_\+action\+:一个可调用对象，在每次从最小优先级队列中弹出最小顶点时立即调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em post\+\_\+action\+:一个可调用对象，在每次从最小优先级队列中弹出最小顶点并处理完它的边时立即调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 最小生成树的权重
\end{DoxyReturn}
{\ttfamily source\+\_\+id}在以下情况下无效：


\begin{DoxyItemize}
\item {\ttfamily source\+\_\+id}不在区间{\ttfamily \mbox{[}0,N)}之间时，{\ttfamily source\+\_\+id}无效
\item {\ttfamily graph}中不存在某个顶点的{\ttfamily id}等于{\ttfamily source\+\_\+id}时，{\ttfamily source\+\_\+id}无效
\end{DoxyItemize}

最小生成树：对于一个连通无向图\+G=(V,E)，对于每一条边(u,v)属于\+E都赋予了一个权重w(u,v)。我们希望找出一个无环子集\+T，其中\+T为\+E的子集，使得所有的顶点\+V位于\+T中， 同时\+T具有最小的权重。由于\+T是无环的，且连通所有结点因此\+T必然是一棵树。我们称这样的树为生成树。称从\+G中求取该生成树的问题为最小生成树问题。

通用的最小生成树使用贪心策略。该策略在每个时刻找到最小生成树的一条边，并在整个策略过程中维持循环不变式：边的集合\+A在每次循环之前是某棵最小生成树的一个子集。

在每一步，选择一条边(u,v)，将其加入集合\+A中，使得\+A不违反循环不变式。称这样的边(u,v)为边集合\+A的安全边。

在\+Prim算法所具有的一个性质是集合\+A中的边总是构成一棵树。这棵树从一个任意的根结点r开始，一直长大到覆盖\+V中的所有结点为止。算法每一步在连接集合\+A和\+A之外的结点的所有边中， 选择一条边加入到\+A中（经特殊选择的边）。

为了有效地实现\+Prim算法，需要一种快速的方法来选择一条新的边以便加入到由集合\+A中的边所构成的树中。在算法执行过程中，所有不在树\+A中的结点都存放在一个基于key的属性的最小优先级队列\+Q中。 对于每个结点v，属性v.\+key保存的是连接v和树中结点的所有边中最小边的权重。若这样的边不存在则权重为正无穷。属性v.\+pai给出的是结点v在树中的父结点。 下面是算法步骤：


\begin{DoxyItemize}
\item 初始化：将所有结点的key设为正无穷，所有结点的父结点置为空(结点构造时，父结点默认为空）
\item 设置源点：将源点的key设为0，
\item 构造最小优先级队列：将所有顶点放入最小优先级队列\+Q中
\item 循环，直到最小优先级队列为空。循环中执行下列操作：
\begin{DoxyItemize}
\item 弹出最小优先级队列的头部顶点u
\item 从结点u出发的所有边，找出它的另一端的结点v。如果v也在\+Q中，且w(u,v)$<$v.\+key，则证明(u,v)是v到集合\+A的最短边，因此设置v.\+pai=u,v.\+key=w(u,v) $>$这里隐含着一个最小优先级队列的decreate\+\_\+key操作
\end{DoxyItemize}
\end{DoxyItemize}

性能：\+Prim总时间代价为\+O(Vlg\+V+\+Elg\+V)=O(\+Elg\+V)(使用最小堆实现的最小优先级队列），或者\+O(E+\+Vlg\+V)（使用斐波那契堆实现最小优先级队列） 

Definition at line 68 of file prim.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_afe2bd83fca7df7e07ece9a59b8e7f5a6}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!relax@{relax}}
\index{relax@{relax}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{relax(std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ from, std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$ to, typename Vertex\+Type\+::\+Key\+Type weight)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vertex\+Type $>$ void Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::relax (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$}]{from, }
\item[{std\+::shared\+\_\+ptr$<$ Vertex\+Type $>$}]{to, }
\item[{typename Vertex\+Type\+::\+Key\+Type}]{weight}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_afe2bd83fca7df7e07ece9a59b8e7f5a6}


relax：单源最短路径的松弛操作，算法导论22章xx节 


\begin{DoxyParams}{Parameters}
{\em from\+:松弛有向边的起始结点，必须非空。若为空则抛出异常} & \\
\hline
{\em to：松弛有向边的终止结点，必须非空且不等于from。若为空或者等于from则抛出异常} & \\
\hline
{\em weight\+:有向边的权重} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: void
\end{DoxyReturn}
对每一个结点v来说，我们维持一个属性v.\+key，它记录了从源结点s到结点v的最短路径权重的上界。我们称v.\+key为s到v的最短路径估计。

松弛过程是测试一下是否可以对从s到v的最短路径进行改善的过程，测试方法为： 将结点s到u之间的最短路径估计加上(u,v)边的权重，并与当前的s到v之间的最短路径估计进行比较。如果前者较小则对v.\+key和v.\+parent进行更新。

性能：时间复杂度\+O(1) 

Definition at line 82 of file bellmanford.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_ac368f242de9f06c7d936cba4aa0ab40b}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!same\+\_\+component@{same\+\_\+component}}
\index{same\+\_\+component@{same\+\_\+component}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{same\+\_\+component(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type id1, typename Graph\+Type\+::\+V\+I\+D\+Type id2)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type $>$ bool Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::same\+\_\+component (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{id1, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{id2}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_ac368f242de9f06c7d936cba4aa0ab40b}


same\+\_\+component：返回无向图的两个顶点是否位于同一个连通分量中。算法导论21章21.1节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强指针，必须非空。若为空则抛出异常} & \\
\hline
{\em id1\+:第一个顶点，必须有效。若无效则抛出异常} & \\
\hline
{\em id2\+:第二个顶点，必须有效。若无效则抛出异常} & 当满足以下条件之一时，id无效的情况：\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item id小于0或者大于等于{\ttfamily Graph\+Type\+::\+N\+U\+M}
\item {\ttfamily graph-\/$>$vertexes.\+at(id1)}为空
\end{DoxyItemize}

在执行 same\+\_\+component函数之前必须先执行 connected\+\_\+component函数对无向图进行预处理。 

Definition at line 143 of file connectedcomponent.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a6d058c2aaa8714778b3f2ab8a24ff232}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!scc@{scc}}
\index{scc@{scc}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{scc(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type $>$ const std\+::vector$<$std\+::vector$<$typename Graph\+Type\+::\+V\+I\+D\+Type$>$ $>$ Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::scc (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a6d058c2aaa8714778b3f2ab8a24ff232}


scc：强连通分量，算法导论22章22.5节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强引用，必须非空。若为空则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+:强连通分量的{\ttfamily std\+::vector}，每一个强连通分量，由一组顶点{\ttfamily id}组成的{\ttfamily std\+::vector}表示。
\end{DoxyReturn}
有向图\+G=(V,E)的强连通分量是一个最大结点集合\+C，\+C是\+V的子集。对于\+C中的任意一对结点u,v来说，路径u--$>$v和路径v--$>$u同时存在。即结点u和结点v之间相互可以到达。

在强连通分量的算法中，需要用到图\+G的转置\+G\+\_\+\+T。定义\+G\+\_\+\+T=(V,E\+\_\+\+T),其中\+E\+\_\+\+T=\{(u,v)\+:(v,u)属于\+E\}，即\+G\+\_\+\+T中的边是\+G中的边进行反向获得。


\begin{DoxyItemize}
\item 图\+G和图\+G\+\_\+\+T的强连通分量相同
\item 可以证明，{\ttfamily scc}算法得到的就是强连通分量。证明见《算法导论》
\end{DoxyItemize}

强连通分量算法步骤：


\begin{DoxyItemize}
\item 对原图\+G执行深度优先搜索，并获取每个结点的完成时间 finish\+\_\+time
\item 对转置图\+G\+\_\+\+T执行深度优先搜索，但是按照 G中结点的一个排序来搜索（这个排序是按照finish\+\_\+time的降序）
\item G\+\_\+\+T的深度优先森林就是强连通分量
\end{DoxyItemize}

性能：时间复杂度\+O(V+\+E) 

Definition at line 48 of file strongconnectedcomponent.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a804241e72be5f4c031190bc12a6b73a2}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!topology\+\_\+sort@{topology\+\_\+sort}}
\index{topology\+\_\+sort@{topology\+\_\+sort}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{topology\+\_\+sort(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type $>$ std\+::vector$<$typename Graph\+Type\+::\+V\+I\+D\+Type$>$ Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::topology\+\_\+sort (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a804241e72be5f4c031190bc12a6b73a2}


topology\+\_\+sort：拓扑排序，算法导论22章22.4节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强引用，必须非空。若为空则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+:拓扑排序结果，它是顶点{\ttfamily id}组成的{\ttfamily std\+::vector}，表示顶点的拓扑排序后的顺序
\end{DoxyReturn}
对于一个有向无环图\+G=（\+V，\+E)，其拓扑排序是\+G中所有结点的一种线性次序，该次序满足如下条件： 如果图\+G包含边(u,v)，则结点u在拓扑排序中处于结点v的前面。

拓扑排序原理：对有向无环图\+G进行深度优先搜索。每当完成一个结点时，将该结点插入到拓扑排序结果的头部。 因此如果将结点按照完成时间降序排列，则得到的就是拓扑排序的结果。

引理：一个有向图\+G=(V,E)是无环的当且仅当对其进行深度优先搜索时不产生后向边。

性能：时间复杂度\+O(V+\+E) 

Definition at line 43 of file topologysort.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_a19237111c3b1ec2717c5e1aefe2f6d9b}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!unlimit@{unlimit}}
\index{unlimit@{unlimit}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{unlimit()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ T Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::unlimit (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_a19237111c3b1ec2717c5e1aefe2f6d9b}


unlimit：返回正无穷的函数 

\begin{DoxyReturn}{Returns}
\+: 正无穷大的数
\end{DoxyReturn}
将本函数的返回值定义为正无穷。在算法导论图算法中，经常用到正无穷。通常对正无穷的操作是\+:


\begin{DoxyItemize}
\item 将边的权重或者节点的{\ttfamily key}设为正无穷
\item 对正无穷加、减一个有限的数，结果还是正无穷
\end{DoxyItemize}

这里将{\ttfamily std\+::numeric\+\_\+limits$<$T$>$\+::max()/2}设为正无穷，考虑到正无穷加上一个较大的数必须保证不能溢出 

Definition at line 110 of file header.\+h.

\hypertarget{namespace_introduction_to_algorithm_1_1_graph_algorithm_af651a2b435fc270ab711e573d83a385d}{}\index{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}!visit@{visit}}
\index{visit@{visit}!Introduction\+To\+Algorithm\+::\+Graph\+Algorithm@{Introduction\+To\+Algorithm\+::\+Graph\+Algorithm}}
\subsubsection[{visit(std\+::shared\+\_\+ptr$<$ Graph\+Type $>$ graph, typename Graph\+Type\+::\+V\+I\+D\+Type v\+\_\+id, int \&time, Action\+Type pre\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, int)\lcurly{}\rcurly{}, Action\+Type post\+\_\+action=[](typename Graph\+Type\+::\+V\+I\+D\+Type, int)\lcurly{}\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Graph\+Type , typename Action\+Type  = std\+::function$<$void(typename Graph\+Type\+::\+V\+I\+D\+Type,int)$>$$>$ void Introduction\+To\+Algorithm\+::\+Graph\+Algorithm\+::visit (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ Graph\+Type $>$}]{graph, }
\item[{typename Graph\+Type\+::\+V\+I\+D\+Type}]{v\+\_\+id, }
\item[{int \&}]{time, }
\item[{Action\+Type}]{pre\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,int)\{\}}, }
\item[{Action\+Type}]{post\+\_\+action = {\ttfamily \mbox{[}\mbox{]}(typename~GraphType\+:\+:VIDType,int)\{\}}}
\end{DoxyParamCaption}
)}\label{namespace_introduction_to_algorithm_1_1_graph_algorithm_af651a2b435fc270ab711e573d83a385d}


visit：深度优先搜索的辅助函数，用于访问顶点，算法导论22章22.3节 


\begin{DoxyParams}{Parameters}
{\em graph\+:指向图的强引用，必须非空。若为空则抛出异常} & \\
\hline
{\em v\+\_\+id\+:待访问顶点的$<$tt$>$id$<$/tt$>$，必须有效。如果无效则抛出异常} & \\
\hline
{\em time\+:访问时刻，是一个引用参数，确保每次$<$tt$>$visit$<$/tt$>$都访问同一个时钟。} & \\
\hline
{\em pre\+\_\+action\+:一个可调用对象，在每次发现一个顶点时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$以及发现时间$<$tt$>$time$<$/tt$>$。默认为空操作，即不进行任何操作} & \\
\hline
{\em post\+\_\+action\+:一个可调用对象，在每次对一个顶点搜索完成时调用，调用参数为该顶点的$<$tt$>$id$<$/tt$>$以及完成时间$<$tt$>$time$<$/tt$>$。默认为空操作，即不进行任何操作} & {\ttfamily v\+\_\+id}在以下情况下无效：\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item {\ttfamily v\+\_\+id}不在区间{\ttfamily \mbox{[}0,N)}之间时，{\ttfamily v\+\_\+id}无效
\item {\ttfamily graph}中不存在某个顶点的{\ttfamily id}等于{\ttfamily v\+\_\+id}时，{\ttfamily v\+\_\+id}无效
\end{DoxyItemize}

在每次对一个结点调用visit的过程中，结点v\+\_\+id的初始颜色都是白色。然后执行下列步骤：


\begin{DoxyItemize}
\item 将全局时间 time 递增
\item 发现结点 v\+\_\+id
\item 对结点 v\+\_\+id 的每一个相邻结点进行检查，在相邻结点是白色的情况下递归访问该相邻结点
\item 当结点 v\+\_\+id 的相邻结点访问完毕，则全局时间 time 递增，然后将结点 v\+\_\+id 设置为完成状态 
\end{DoxyItemize}

Definition at line 160 of file dfs.\+h.

