\hypertarget{namespace_introdunction_to_algorithm_1_1_sort_algorithm}{}\section{Introdunction\+To\+Algorithm\+:\+:Sort\+Algorithm Namespace Reference}
\label{namespace_introdunction_to_algorithm_1_1_sort_algorithm}\index{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}}


Namespace of \hyperlink{namespace_introdunction_to_algorithm_1_1_sort_algorithm}{Sort\+Algorithm}.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Iterator $>$ }\\void \hyperlink{namespace_introdunction_to_algorithm_1_1_sort_algorithm_afc447bdeb9c5e6a3611d8daa4edef33d}{insert\+\_\+sort} (Iterator begin, Iterator end, bool($\ast$compare)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)=\mbox{[}$\,$\mbox{]}(Iterator iter\+\_\+little, Iterator iter\+\_\+big)\{return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\})
\begin{DoxyCompactList}\small\item\em insert\+\_\+sort：算法导论第二章 2.\+1 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Iterator $>$ }\\void \hyperlink{namespace_introdunction_to_algorithm_1_1_sort_algorithm_a1c50cf3a021ad0abf02a3fd398a42dda}{merge} (Iterator begin, Iterator end, Iterator middle, bool($\ast$compare)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)=\mbox{[}$\,$\mbox{]}(Iterator iter\+\_\+little, Iterator iter\+\_\+big)\{return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\})
\begin{DoxyCompactList}\small\item\em merge：算法导论第二章 2.\+3.\+1 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Iterator $>$ }\\void \hyperlink{namespace_introdunction_to_algorithm_1_1_sort_algorithm_a01bb990e5f682e3cb75dd54d792fae50}{merge\+\_\+sort} (Iterator begin, Iterator end, bool($\ast$compare)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)=\mbox{[}$\,$\mbox{]}(Iterator iter\+\_\+little, Iterator iter\+\_\+big)\{return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\})
\begin{DoxyCompactList}\small\item\em merge\+\_\+sort：算法导论第二章 2.\+3.\+1 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Iterator $>$ }\\void \hyperlink{namespace_introdunction_to_algorithm_1_1_sort_algorithm_aacc87ff4087dcdcae65164f24b47aa7c}{quick\+\_\+sort} (Iterator begin, Iterator end, bool($\ast$compare)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)=\mbox{[}$\,$\mbox{]}(Iterator iter\+\_\+little, Iterator iter\+\_\+big)\{return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\})
\begin{DoxyCompactList}\small\item\em quick\+\_\+sort： 算法导论第7章 \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace of \hyperlink{namespace_introdunction_to_algorithm_1_1_sort_algorithm}{Sort\+Algorithm}. 

该命名空间内包含所有排序算法 

\subsection{Function Documentation}
\hypertarget{namespace_introdunction_to_algorithm_1_1_sort_algorithm_afc447bdeb9c5e6a3611d8daa4edef33d}{}\index{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}!insert\+\_\+sort@{insert\+\_\+sort}}
\index{insert\+\_\+sort@{insert\+\_\+sort}!Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}}
\subsubsection[{insert\+\_\+sort(\+Iterator begin, Iterator end, bool($\ast$compare)(\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)=[](\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)\lcurly{}return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator $>$ void Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm\+::insert\+\_\+sort (
\begin{DoxyParamCaption}
\item[{Iterator}]{begin, }
\item[{Iterator}]{end, }
\item[{bool($\ast$)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)}]{compare = {\ttfamily \mbox{[}\mbox{]}(Iterator~iter\+\_\+little,Iterator~iter\+\_\+big)\{return~$\ast$iter\+\_\+little$<$~$\ast$iter\+\_\+big;\}}}
\end{DoxyParamCaption}
)}\label{namespace_introdunction_to_algorithm_1_1_sort_algorithm_afc447bdeb9c5e6a3611d8daa4edef33d}


insert\+\_\+sort：算法导论第二章 2.\+1 


\begin{DoxyParams}{Parameters}
{\em begin} & \+: 待排序序列的起始迭代器 \\
\hline
{\em end} & 待排序序列的终止迭代器 \\
\hline
{\em compare} & 一个用于排序的可调用对象，接受两个 Iterator对象，返回布尔值（若前者指向的对象小于后者指向的对象，则返回 true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}

\begin{DoxyItemize}
\item 插入排序思想，假设对数组\+A\mbox{[}p...r\mbox{]}排序：
\begin{DoxyItemize}
\item 维持不变式：设当前排序的元素是 A\mbox{[}q\mbox{]}，则保持\+A\mbox{[}p...q-\/1\mbox{]}为排好的，\+A\mbox{[}q\mbox{]}在\+A\mbox{[}p...q-\/1\mbox{]}中找到它的位置坐下
\end{DoxyItemize}
\item 时间复杂度 O(n$^\wedge$2)
\item 原地排序 
\end{DoxyItemize}

Definition at line 21 of file insertsort.\+h.

\hypertarget{namespace_introdunction_to_algorithm_1_1_sort_algorithm_a1c50cf3a021ad0abf02a3fd398a42dda}{}\index{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}!merge@{merge}}
\index{merge@{merge}!Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}}
\subsubsection[{merge(\+Iterator begin, Iterator end, Iterator middle, bool($\ast$compare)(\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)=[](\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)\lcurly{}return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator $>$ void Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm\+::merge (
\begin{DoxyParamCaption}
\item[{Iterator}]{begin, }
\item[{Iterator}]{end, }
\item[{Iterator}]{middle, }
\item[{bool($\ast$)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)}]{compare = {\ttfamily \mbox{[}\mbox{]}(Iterator~iter\+\_\+little,Iterator~iter\+\_\+big)\{return~$\ast$iter\+\_\+little$<$~$\ast$iter\+\_\+big;\}}}
\end{DoxyParamCaption}
)}\label{namespace_introdunction_to_algorithm_1_1_sort_algorithm_a1c50cf3a021ad0abf02a3fd398a42dda}


merge：算法导论第二章 2.\+3.\+1 


\begin{DoxyParams}{Parameters}
{\em begin} & \+: begin...middle之间为已排好序列 \\
\hline
{\em end} & middle...end之间为已排好序列 \\
\hline
{\em middle} & begin...middle之间为已排好序列 \\
\hline
{\em compare} & 一个用于排序的可调用对象，接受两个 Iterator对象，返回布尔值（若前者指向的对象小于后者指向的对象，则返回 true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}

\begin{DoxyItemize}
\item 归并思想，假设对数组\+A\mbox{[}p...q...r\mbox{]}归并：
\begin{DoxyItemize}
\item 拷贝：将数组\+A\mbox{[}p...q\mbox{]}拷贝到数组\+L，将数组\+A\mbox{[}q...r\mbox{]}拷贝到数组\+R，
\item 归并： 从左到右依次取\+L、\+R中的较小的元素，存放到\+A中（具体算法见代码）
\end{DoxyItemize}
\item 时间复杂度 O(n)
\item 归并时需要额外的空间 O(n) 
\end{DoxyItemize}

Definition at line 23 of file mergesort.\+h.

\hypertarget{namespace_introdunction_to_algorithm_1_1_sort_algorithm_a01bb990e5f682e3cb75dd54d792fae50}{}\index{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}!merge\+\_\+sort@{merge\+\_\+sort}}
\index{merge\+\_\+sort@{merge\+\_\+sort}!Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}}
\subsubsection[{merge\+\_\+sort(\+Iterator begin, Iterator end, bool($\ast$compare)(\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)=[](\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)\lcurly{}return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator $>$ void Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm\+::merge\+\_\+sort (
\begin{DoxyParamCaption}
\item[{Iterator}]{begin, }
\item[{Iterator}]{end, }
\item[{bool($\ast$)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)}]{compare = {\ttfamily \mbox{[}\mbox{]}(Iterator~iter\+\_\+little,Iterator~iter\+\_\+big)\{return~$\ast$iter\+\_\+little$<$~$\ast$iter\+\_\+big;\}}}
\end{DoxyParamCaption}
)}\label{namespace_introdunction_to_algorithm_1_1_sort_algorithm_a01bb990e5f682e3cb75dd54d792fae50}


merge\+\_\+sort：算法导论第二章 2.\+3.\+1 


\begin{DoxyParams}{Parameters}
{\em begin} & \+: 待排序序列的起始迭代器 \\
\hline
{\em end} & 待排序序列的终止迭代器 \\
\hline
{\em compare} & 一个用于排序的可调用对象，接受两个 Iterator对象，返回布尔值（若前者指向的对象小于后者指向的对象，则返回 true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}

\begin{DoxyItemize}
\item 归并排序思想，假设对数组\+A\mbox{[}p...r\mbox{]}排序：
\begin{DoxyItemize}
\item 分解：将数组\+A\mbox{[}p...r\mbox{]}平均划分为2子数组\+A\mbox{[}p...q-\/1\mbox{]}个\+A\mbox{[}q...r\mbox{]}，一直划分直到每个子数组只有1个元素
\item 归并： 对 A\mbox{[}p...q-\/1\mbox{]}和\+A\mbox{[}q...r\mbox{]}这两个已排序好的数组进行合并
\end{DoxyItemize}
\item 时间复杂度 O(nlgn)
\item 非原地排序，归并时需要额外的空间 O(n) 
\end{DoxyItemize}

Definition at line 66 of file mergesort.\+h.

\hypertarget{namespace_introdunction_to_algorithm_1_1_sort_algorithm_aacc87ff4087dcdcae65164f24b47aa7c}{}\index{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}!quick\+\_\+sort@{quick\+\_\+sort}}
\index{quick\+\_\+sort@{quick\+\_\+sort}!Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm@{Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm}}
\subsubsection[{quick\+\_\+sort(\+Iterator begin, Iterator end, bool($\ast$compare)(\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)=[](\+Iterator iter\+\_\+little, Iterator iter\+\_\+big)\lcurly{}return $\ast$iter\+\_\+little$<$ $\ast$iter\+\_\+big;\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator $>$ void Introdunction\+To\+Algorithm\+::\+Sort\+Algorithm\+::quick\+\_\+sort (
\begin{DoxyParamCaption}
\item[{Iterator}]{begin, }
\item[{Iterator}]{end, }
\item[{bool($\ast$)(Iterator iter\+\_\+little, Iterator iter\+\_\+big)}]{compare = {\ttfamily \mbox{[}\mbox{]}(Iterator~iter\+\_\+little,Iterator~iter\+\_\+big)\{return~$\ast$iter\+\_\+little$<$~$\ast$iter\+\_\+big;\}}}
\end{DoxyParamCaption}
)}\label{namespace_introdunction_to_algorithm_1_1_sort_algorithm_aacc87ff4087dcdcae65164f24b47aa7c}


quick\+\_\+sort： 算法导论第7章 


\begin{DoxyParams}{Parameters}
{\em begin} & \+: 待排序序列的起始迭代器 \\
\hline
{\em end} & 待排序序列的终止迭代器 \\
\hline
{\em compare} & 一个用于排序的可调用对象，接受两个 Iterator对象，返回布尔值（若前者指向的对象小于后者指向的对象，则返回 true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}

\begin{DoxyItemize}
\item 快速排序思想，假设对数组\+A\mbox{[}p...r\mbox{]}排序：
\begin{DoxyItemize}
\item 分解：将数组\+A\mbox{[}p...r\mbox{]}划分为两个（可能为空）的子数组\+A\mbox{[}p...q-\/1\mbox{]}个\+A\mbox{[}q+1...r\mbox{]}，使得\+A\mbox{[}q\mbox{]}大于前面一个数组中每个元素，小于后面一个数组中每个元素
\item 解决： 对 A\mbox{[}p...q-\/1\mbox{]}和\+A\mbox{[}q+1...r\mbox{]}递归调用快速排序
\end{DoxyItemize}
\item 最坏时间复杂度 O(n$^\wedge$2)， 期望时间复杂度 O(nlgn)。它平均性能非常好，是实际排序应用中最好的选择
\item 原地排序 
\end{DoxyItemize}

Definition at line 21 of file quicksort.\+h.

